/* automatically generated by rust-bindgen */

#![allow(non_camel_case_types)]

pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __size_t = __uint64_t;
pub type __off_t = __int64_t;
pub type fpos_t = __off_t;
#[repr(u32)]
#[doc = " The common error codes returned by ucl parser"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ucl_error {
    #[doc = "< No error"]
    UCL_EOK = 0,
    #[doc = "< Syntax error occurred during parsing"]
    UCL_ESYNTAX = 1,
    #[doc = "< IO error occurred during parsing"]
    UCL_EIO = 2,
    #[doc = "< Invalid state machine state"]
    UCL_ESTATE = 3,
    #[doc = "< Input has too many recursion levels"]
    UCL_ENESTED = 4,
    #[doc = "< Error processing a macro"]
    UCL_EMACRO = 5,
    #[doc = "< Internal unclassified error"]
    UCL_EINTERNAL = 6,
    #[doc = "< SSL error"]
    UCL_ESSL = 7,
    #[doc = "< A merge error occured"]
    UCL_EMERGE = 8,
}
pub use self::ucl_error as ucl_error_t;
#[repr(u32)]
#[doc = " #ucl_object_t may have one of specified types, some types are compatible with each other and some are not."]
#[doc = " For example, you can always convert #UCL_TIME to #UCL_FLOAT. Also you can convert #UCL_FLOAT to #UCL_INTEGER"]
#[doc = " by loosing floating point. Every object may be converted to a string by #ucl_object_tostring_forced() function."]
#[doc = ""]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ucl_type {
    #[doc = "< UCL object - key/value pairs"]
    UCL_OBJECT = 0,
    #[doc = "< UCL array"]
    UCL_ARRAY = 1,
    #[doc = "< Integer number"]
    UCL_INT = 2,
    #[doc = "< Floating point number"]
    UCL_FLOAT = 3,
    #[doc = "< Null terminated string"]
    UCL_STRING = 4,
    #[doc = "< Boolean value"]
    UCL_BOOLEAN = 5,
    #[doc = "< Time value (floating point number of seconds)"]
    UCL_TIME = 6,
    #[doc = "< Opaque userdata pointer (may be used in macros)"]
    UCL_USERDATA = 7,
    #[doc = "< Null value"]
    UCL_NULL = 8,
}
pub use self::ucl_type as ucl_type_t;
#[repr(u32)]
#[doc = " You can use one of these types to serialise #ucl_object_t by using ucl_object_emit()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ucl_emitter {
    #[doc = "< Emit fine formatted JSON"]
    UCL_EMIT_JSON = 0,
    #[doc = "< Emit compacted JSON"]
    UCL_EMIT_JSON_COMPACT = 1,
    #[doc = "< Emit human readable config format"]
    UCL_EMIT_CONFIG = 2,
    #[doc = "< Emit embedded YAML format"]
    UCL_EMIT_YAML = 3,
    #[doc = "< Emit msgpack output"]
    UCL_EMIT_MSGPACK = 4,
    #[doc = "< Unsupported emitter type"]
    UCL_EMIT_MAX = 5,
}
pub use self::ucl_emitter as ucl_emitter_t;
impl ucl_parser_flags {
    #[doc = "< No special flags"]
    pub const UCL_PARSER_DEFAULT: ucl_parser_flags = ucl_parser_flags(0);
}
impl ucl_parser_flags {
    #[doc = "< Convert all keys to lower case"]
    pub const UCL_PARSER_KEY_LOWERCASE: ucl_parser_flags = ucl_parser_flags(1);
}
impl ucl_parser_flags {
    #[doc = "< Parse input in zero-copy mode if possible"]
    pub const UCL_PARSER_ZEROCOPY: ucl_parser_flags = ucl_parser_flags(2);
}
impl ucl_parser_flags {
    #[doc = "< Do not parse time and treat time values as strings"]
    pub const UCL_PARSER_NO_TIME: ucl_parser_flags = ucl_parser_flags(4);
}
impl ucl_parser_flags {
    pub const UCL_PARSER_NO_IMPLICIT_ARRAYS: ucl_parser_flags = ucl_parser_flags(8);
}
impl ucl_parser_flags {
    #[doc = " Create explicit arrays instead of implicit ones"]
    pub const UCL_PARSER_SAVE_COMMENTS: ucl_parser_flags = ucl_parser_flags(16);
}
impl ucl_parser_flags {
    #[doc = " Save comments in the parser context"]
    pub const UCL_PARSER_DISABLE_MACRO: ucl_parser_flags = ucl_parser_flags(32);
}
impl ucl_parser_flags {
    #[doc = " Treat macros as comments"]
    pub const UCL_PARSER_NO_FILEVARS: ucl_parser_flags = ucl_parser_flags(64);
}
impl ::std::ops::BitOr<ucl_parser_flags> for ucl_parser_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucl_parser_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucl_parser_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucl_parser_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucl_parser_flags> for ucl_parser_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucl_parser_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucl_parser_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucl_parser_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " These flags defines parser behaviour. If you specify #UCL_PARSER_ZEROCOPY you must ensure"]
#[doc = " that the input memory is not freed if an object is in use. Moreover, if you want to use"]
#[doc = " zero-terminated keys and string values then you should not use zero-copy mode, as in this case"]
#[doc = " UCL still has to perform copying implicitly."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ucl_parser_flags(pub u32);
pub use self::ucl_parser_flags as ucl_parser_flags_t;
impl ucl_string_flags {
    #[doc = "< Treat string as is"]
    pub const UCL_STRING_RAW: ucl_string_flags = ucl_string_flags(0);
}
impl ucl_string_flags {
    #[doc = "< Perform JSON escape"]
    pub const UCL_STRING_ESCAPE: ucl_string_flags = ucl_string_flags(1);
}
impl ucl_string_flags {
    #[doc = "< Trim leading and trailing whitespaces"]
    pub const UCL_STRING_TRIM: ucl_string_flags = ucl_string_flags(2);
}
impl ucl_string_flags {
    #[doc = "< Parse passed string and detect boolean"]
    pub const UCL_STRING_PARSE_BOOLEAN: ucl_string_flags = ucl_string_flags(4);
}
impl ucl_string_flags {
    #[doc = "< Parse passed string and detect integer number"]
    pub const UCL_STRING_PARSE_INT: ucl_string_flags = ucl_string_flags(8);
}
impl ucl_string_flags {
    #[doc = "< Parse passed string and detect integer or float number"]
    pub const UCL_STRING_PARSE_DOUBLE: ucl_string_flags = ucl_string_flags(16);
}
impl ucl_string_flags {
    #[doc = "< Parse time strings"]
    pub const UCL_STRING_PARSE_TIME: ucl_string_flags = ucl_string_flags(32);
}
impl ucl_string_flags {
    #[doc = "<"]
    #[doc = "Parse passed string and detect number"]
    pub const UCL_STRING_PARSE_NUMBER: ucl_string_flags = ucl_string_flags(56);
}
impl ucl_string_flags {
    #[doc = "<"]
    #[doc = "Parse passed string (and detect booleans and numbers)"]
    pub const UCL_STRING_PARSE: ucl_string_flags = ucl_string_flags(60);
}
impl ucl_string_flags {
    #[doc = "< Treat numbers as bytes"]
    pub const UCL_STRING_PARSE_BYTES: ucl_string_flags = ucl_string_flags(64);
}
impl ::std::ops::BitOr<ucl_string_flags> for ucl_string_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucl_string_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucl_string_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucl_string_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucl_string_flags> for ucl_string_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucl_string_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucl_string_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucl_string_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " String conversion flags, that are used in #ucl_object_fromstring_common function."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ucl_string_flags(pub u32);
pub use self::ucl_string_flags as ucl_string_flags_t;
impl ucl_object_flags {
    #[doc = "< An object has key allocated internally"]
    pub const UCL_OBJECT_ALLOCATED_KEY: ucl_object_flags = ucl_object_flags(1);
}
impl ucl_object_flags {
    #[doc = "< An object has a string value allocated internally"]
    pub const UCL_OBJECT_ALLOCATED_VALUE: ucl_object_flags = ucl_object_flags(2);
}
impl ucl_object_flags {
    #[doc = "< The key of an object need to be escaped on output"]
    pub const UCL_OBJECT_NEED_KEY_ESCAPE: ucl_object_flags = ucl_object_flags(4);
}
impl ucl_object_flags {
    #[doc = "< Temporary object that does not need to be freed really"]
    pub const UCL_OBJECT_EPHEMERAL: ucl_object_flags = ucl_object_flags(8);
}
impl ucl_object_flags {
    #[doc = "< String should be displayed as multiline string"]
    pub const UCL_OBJECT_MULTILINE: ucl_object_flags = ucl_object_flags(16);
}
impl ucl_object_flags {
    #[doc = "< Object is a key with multiple values"]
    pub const UCL_OBJECT_MULTIVALUE: ucl_object_flags = ucl_object_flags(32);
}
impl ucl_object_flags {
    #[doc = "< Object has been inherited from another"]
    pub const UCL_OBJECT_INHERITED: ucl_object_flags = ucl_object_flags(64);
}
impl ucl_object_flags {
    #[doc = "< Object contains raw binary data"]
    pub const UCL_OBJECT_BINARY: ucl_object_flags = ucl_object_flags(128);
}
impl ::std::ops::BitOr<ucl_object_flags> for ucl_object_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ucl_object_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ucl_object_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ucl_object_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ucl_object_flags> for ucl_object_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ucl_object_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ucl_object_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ucl_object_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " Basic flags for an object"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ucl_object_flags(pub u32);
pub use self::ucl_object_flags as ucl_object_flags_t;
#[repr(u32)]
#[doc = " Duplicate policy types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ucl_duplicate_strategy {
    #[doc = "< Default policy to merge based on priorities"]
    UCL_DUPLICATE_APPEND = 0,
    #[doc = "< Merge new object with old one"]
    UCL_DUPLICATE_MERGE = 1,
    #[doc = "< Rewrite old keys"]
    UCL_DUPLICATE_REWRITE = 2,
    #[doc = "< Stop parsing on duplicate found"]
    UCL_DUPLICATE_ERROR = 3,
}
#[repr(u32)]
#[doc = " Input format type"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ucl_parse_type {
    #[doc = "< Default ucl format"]
    UCL_PARSE_UCL = 0,
    #[doc = "< Message pack input format"]
    UCL_PARSE_MSGPACK = 1,
    #[doc = "< Canonical S-expressions"]
    UCL_PARSE_CSEXP = 2,
    #[doc = "< Try to detect parse type"]
    UCL_PARSE_AUTO = 3,
}
#[doc = " UCL object structure. Please mention that the most of fields should not be touched by"]
#[doc = " UCL users. In future, this structure may be converted to private one."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ucl_object_s {
    pub _bindgen_opaque_blob: [u64; 8usize],
}
#[doc = " Variant value type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ucl_object_s__bindgen_ty_1 {
    #[doc = "< Int value of an object"]
    pub iv: i64,
    #[doc = "< String value of an object"]
    pub sv: *const ::std::os::raw::c_char,
    #[doc = "< Double value of an object"]
    pub dv: f64,
    #[doc = "< Array"]
    pub av: *mut ::std::os::raw::c_void,
    #[doc = "< Object"]
    pub ov: *mut ::std::os::raw::c_void,
    #[doc = "< Opaque user data"]
    pub ud: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ucl_object_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ucl_object_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ucl_object_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ucl_object_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ucl_object_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_object_s__bindgen_ty_1>())).iv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_object_s__bindgen_ty_1),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_object_s__bindgen_ty_1>())).sv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_object_s__bindgen_ty_1),
            "::",
            stringify!(sv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_object_s__bindgen_ty_1>())).dv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_object_s__bindgen_ty_1),
            "::",
            stringify!(dv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_object_s__bindgen_ty_1>())).av as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_object_s__bindgen_ty_1),
            "::",
            stringify!(av)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_object_s__bindgen_ty_1>())).ov as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_object_s__bindgen_ty_1),
            "::",
            stringify!(ov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_object_s__bindgen_ty_1>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_object_s__bindgen_ty_1),
            "::",
            stringify!(ud)
        )
    );
}
#[test]
fn bindgen_test_layout_ucl_object_s() {
    assert_eq!(
        ::std::mem::size_of::<ucl_object_s>(),
        64usize,
        concat!("Size of: ", stringify!(ucl_object_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ucl_object_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ucl_object_s))
    );
}
pub type ucl_object_t = ucl_object_s;
#[doc = " Destructor type for userdata objects"]
#[doc = " @param ud user specified data pointer"]
pub type ucl_userdata_dtor =
    ::std::option::Option<unsafe extern "C" fn(ud: *mut ::std::os::raw::c_void)>;
pub type ucl_userdata_emitter = ::std::option::Option<
    unsafe extern "C" fn(ud: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
>;
extern "C" {
    #[doc = " @defgroup utils Utility functions"]
    #[doc = " A number of utility functions simplify handling of UCL objects"]
    #[doc = ""]
    #[doc = " @{"]
    #[doc = " Copy and return a key of an object, returned key is zero-terminated"]
    #[doc = " @param obj CL object"]
    #[doc = " @return zero terminated key"]
    pub fn ucl_copy_key_trash(obj: *const ucl_object_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy and return a string value of an object, returned key is zero-terminated"]
    #[doc = " @param obj CL object"]
    #[doc = " @return zero terminated string representation of object value"]
    pub fn ucl_copy_value_trash(obj: *const ucl_object_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a new object"]
    #[doc = " @return new object"]
    pub fn ucl_object_new() -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create new object with type specified"]
    #[doc = " @param type type of a new object"]
    #[doc = " @return new object"]
    pub fn ucl_object_typed_new(type_: ucl_type_t) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create new object with type and priority specified"]
    #[doc = " @param type type of a new object"]
    #[doc = " @param priority priority of an object"]
    #[doc = " @return new object"]
    pub fn ucl_object_new_full(
        type_: ucl_type_t,
        priority: ::std::os::raw::c_uint,
    ) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create new object with userdata dtor"]
    #[doc = " @param dtor destructor function"]
    #[doc = " @param emitter emitter for userdata"]
    #[doc = " @param ptr opaque pointer"]
    #[doc = " @return new object"]
    pub fn ucl_object_new_userdata(
        dtor: ucl_userdata_dtor,
        emitter: ucl_userdata_emitter,
        ptr: *mut ::std::os::raw::c_void,
    ) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Perform deep copy of an object copying everything"]
    #[doc = " @param other object to copy"]
    #[doc = " @return new object with refcount equal to 1"]
    pub fn ucl_object_copy(other: *const ucl_object_t) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Return the type of an object"]
    #[doc = " @return the object type"]
    pub fn ucl_object_type(obj: *const ucl_object_t) -> ucl_type_t;
}
extern "C" {
    #[doc = " Converts ucl object type to its string representation"]
    #[doc = " @param type type of object"]
    #[doc = " @return constant string describing type"]
    pub fn ucl_object_type_to_string(type_: ucl_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Converts string that represents ucl type to real ucl type enum"]
    #[doc = " @param input C string with name of type"]
    #[doc = " @param res resulting target"]
    #[doc = " @return true if `input` is a name of type stored in `res`"]
    pub fn ucl_object_string_to_type(
        input: *const ::std::os::raw::c_char,
        res: *mut ucl_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Convert any string to an ucl object making the specified transformations"]
    #[doc = " @param str fixed size or NULL terminated string"]
    #[doc = " @param len length (if len is zero, than str is treated as NULL terminated)"]
    #[doc = " @param flags conversion flags"]
    #[doc = " @return new object"]
    pub fn ucl_object_fromstring_common(
        str: *const ::std::os::raw::c_char,
        len: usize,
        flags: ucl_string_flags,
    ) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create a UCL object from the specified string"]
    #[doc = " @param str NULL terminated string, will be json escaped"]
    #[doc = " @return new object"]
    pub fn ucl_object_fromstring(str: *const ::std::os::raw::c_char) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create a UCL object from the specified string"]
    #[doc = " @param str fixed size string, will be json escaped"]
    #[doc = " @param len length of a string"]
    #[doc = " @return new object"]
    pub fn ucl_object_fromlstring(
        str: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create an object from an integer number"]
    #[doc = " @param iv number"]
    #[doc = " @return new object"]
    pub fn ucl_object_fromint(iv: i64) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create an object from a float number"]
    #[doc = " @param dv number"]
    #[doc = " @return new object"]
    pub fn ucl_object_fromdouble(dv: f64) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Create an object from a boolean"]
    #[doc = " @param bv bool value"]
    #[doc = " @return new object"]
    pub fn ucl_object_frombool(bv: bool) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Insert a object 'elt' to the hash 'top' and associate it with key 'key'"]
    #[doc = " @param top destination object (must be of type UCL_OBJECT)"]
    #[doc = " @param elt element to insert (must NOT be NULL)"]
    #[doc = " @param key key to associate with this object (either const or preallocated)"]
    #[doc = " @param keylen length of the key (or 0 for NULL terminated keys)"]
    #[doc = " @param copy_key make an internal copy of key"]
    #[doc = " @return true if key has been inserted"]
    pub fn ucl_object_insert_key(
        top: *mut ucl_object_t,
        elt: *mut ucl_object_t,
        key: *const ::std::os::raw::c_char,
        keylen: usize,
        copy_key: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Replace a object 'elt' to the hash 'top' and associate it with key 'key', old object will be unrefed,"]
    #[doc = " if no object has been found this function works like ucl_object_insert_key()"]
    #[doc = " @param top destination object (must be of type UCL_OBJECT)"]
    #[doc = " @param elt element to insert (must NOT be NULL)"]
    #[doc = " @param key key to associate with this object (either const or preallocated)"]
    #[doc = " @param keylen length of the key (or 0 for NULL terminated keys)"]
    #[doc = " @param copy_key make an internal copy of key"]
    #[doc = " @return true if key has been inserted"]
    pub fn ucl_object_replace_key(
        top: *mut ucl_object_t,
        elt: *mut ucl_object_t,
        key: *const ::std::os::raw::c_char,
        keylen: usize,
        copy_key: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Merge the keys from one object to another object. Overwrite on conflict"]
    #[doc = " @param top destination object (must be of type UCL_OBJECT)"]
    #[doc = " @param elt element to insert (must be of type UCL_OBJECT)"]
    #[doc = " @param copy copy rather than reference the elements"]
    #[doc = " @return true if all keys have been merged"]
    pub fn ucl_object_merge(top: *mut ucl_object_t, elt: *mut ucl_object_t, copy: bool) -> bool;
}
extern "C" {
    #[doc = " Delete a object associated with key 'key', old object will be unrefered,"]
    #[doc = " @param top object"]
    #[doc = " @param key key associated to the object to remove"]
    #[doc = " @param keylen length of the key (or 0 for NULL terminated keys)"]
    pub fn ucl_object_delete_keyl(
        top: *mut ucl_object_t,
        key: *const ::std::os::raw::c_char,
        keylen: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete a object associated with key 'key', old object will be unrefered,"]
    #[doc = " @param top object"]
    #[doc = " @param key key associated to the object to remove"]
    pub fn ucl_object_delete_key(
        top: *mut ucl_object_t,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Removes `key` from `top` object, returning the object that was removed. This"]
    #[doc = " object is not released, caller must unref the returned object when it is no"]
    #[doc = " longer needed."]
    #[doc = " @param top object"]
    #[doc = " @param key key to remove"]
    #[doc = " @param keylen length of the key (or 0 for NULL terminated keys)"]
    #[doc = " @return removed object or NULL if object has not been found"]
    pub fn ucl_object_pop_keyl(
        top: *mut ucl_object_t,
        key: *const ::std::os::raw::c_char,
        keylen: usize,
    ) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Removes `key` from `top` object returning the object that was removed. This"]
    #[doc = " object is not released, caller must unref the returned object when it is no"]
    #[doc = " longer needed."]
    #[doc = " @param top object"]
    #[doc = " @param key key to remove"]
    #[doc = " @return removed object or NULL if object has not been found"]
    pub fn ucl_object_pop_key(
        top: *mut ucl_object_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Insert a object 'elt' to the hash 'top' and associate it with key 'key', if"]
    #[doc = " the specified key exist, try to merge its content"]
    #[doc = " @param top destination object (must be of type UCL_OBJECT)"]
    #[doc = " @param elt element to insert (must NOT be NULL)"]
    #[doc = " @param key key to associate with this object (either const or preallocated)"]
    #[doc = " @param keylen length of the key (or 0 for NULL terminated keys)"]
    #[doc = " @param copy_key make an internal copy of key"]
    #[doc = " @return true if key has been inserted"]
    pub fn ucl_object_insert_key_merged(
        top: *mut ucl_object_t,
        elt: *mut ucl_object_t,
        key: *const ::std::os::raw::c_char,
        keylen: usize,
        copy_key: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Append an element to the end of array object"]
    #[doc = " @param top destination object (must NOT be NULL)"]
    #[doc = " @param elt element to append (must NOT be NULL)"]
    #[doc = " @return true if value has been inserted"]
    pub fn ucl_array_append(top: *mut ucl_object_t, elt: *mut ucl_object_t) -> bool;
}
extern "C" {
    #[doc = " Append an element to the start of array object"]
    #[doc = " @param top destination object (must NOT be NULL)"]
    #[doc = " @param elt element to append (must NOT be NULL)"]
    #[doc = " @return true if value has been inserted"]
    pub fn ucl_array_prepend(top: *mut ucl_object_t, elt: *mut ucl_object_t) -> bool;
}
extern "C" {
    #[doc = " Merge all elements of second array into the first array"]
    #[doc = " @param top destination array (must be of type UCL_ARRAY)"]
    #[doc = " @param elt array to copy elements from (must be of type UCL_ARRAY)"]
    #[doc = " @param copy copy elements instead of referencing them"]
    #[doc = " @return true if arrays were merged"]
    pub fn ucl_array_merge(top: *mut ucl_object_t, elt: *mut ucl_object_t, copy: bool) -> bool;
}
extern "C" {
    #[doc = " Removes an element `elt` from the array `top`, returning the object that was"]
    #[doc = " removed. This object is not released, caller must unref the returned object"]
    #[doc = " when it is no longer needed."]
    #[doc = " @param top array ucl object"]
    #[doc = " @param elt element to remove"]
    #[doc = " @return removed element or NULL if `top` is NULL or not an array"]
    pub fn ucl_array_delete(top: *mut ucl_object_t, elt: *mut ucl_object_t) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Returns the first element of the array `top`"]
    #[doc = " @param top array ucl object"]
    #[doc = " @return element or NULL if `top` is NULL or not an array"]
    pub fn ucl_array_head(top: *const ucl_object_t) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Returns the last element of the array `top`"]
    #[doc = " @param top array ucl object"]
    #[doc = " @return element or NULL if `top` is NULL or not an array"]
    pub fn ucl_array_tail(top: *const ucl_object_t) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Removes the last element from the array `top`, returning the object that was"]
    #[doc = " removed. This object is not released, caller must unref the returned object"]
    #[doc = " when it is no longer needed."]
    #[doc = " @param top array ucl object"]
    #[doc = " @return removed element or NULL if `top` is NULL or not an array"]
    pub fn ucl_array_pop_last(top: *mut ucl_object_t) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Removes the first element from the array `top`, returning the object that was"]
    #[doc = " removed. This object is not released, caller must unref the returned object"]
    #[doc = " when it is no longer needed."]
    #[doc = " @param top array ucl object"]
    #[doc = " @return removed element or NULL if `top` is NULL or not an array"]
    pub fn ucl_array_pop_first(top: *mut ucl_object_t) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Return object identified by index of the array `top`"]
    #[doc = " @param top object to get a key from (must be of type UCL_ARRAY)"]
    #[doc = " @param index array index to return"]
    #[doc = " @return object at the specified index or NULL if index is not found"]
    pub fn ucl_array_find_index(
        top: *const ucl_object_t,
        index: ::std::os::raw::c_uint,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Return the index of `elt` in the array `top`"]
    #[doc = " @param top object to get a key from (must be of type UCL_ARRAY)"]
    #[doc = " @param elt element to find index of (must NOT be NULL)"]
    #[doc = " @return index of `elt` in the array `top or (unsigned int)-1 if `elt` is not found"]
    pub fn ucl_array_index_of(
        top: *mut ucl_object_t,
        elt: *mut ucl_object_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Replace an element in an array with a different element, returning the object"]
    #[doc = " that was replaced. This object is not released, caller must unref the"]
    #[doc = " returned object when it is no longer needed."]
    #[doc = " @param top destination object (must be of type UCL_ARRAY)"]
    #[doc = " @param elt element to append (must NOT be NULL)"]
    #[doc = " @param index array index in destination to overwrite with elt"]
    #[doc = " @return object that was replaced or NULL if index is not found"]
    pub fn ucl_array_replace_index(
        top: *mut ucl_object_t,
        elt: *mut ucl_object_t,
        index: ::std::os::raw::c_uint,
    ) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Append a element to another element forming an implicit array"]
    #[doc = " @param head head to append (may be NULL)"]
    #[doc = " @param elt new element"]
    #[doc = " @return the new implicit array"]
    pub fn ucl_elt_append(head: *mut ucl_object_t, elt: *mut ucl_object_t) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Converts an object to double value"]
    #[doc = " @param obj CL object"]
    #[doc = " @param target target double variable"]
    #[doc = " @return true if conversion was successful"]
    pub fn ucl_object_todouble_safe(obj: *const ucl_object_t, target: *mut f64) -> bool;
}
extern "C" {
    #[doc = " Unsafe version of \\ref ucl_obj_todouble_safe"]
    #[doc = " @param obj CL object"]
    #[doc = " @return double value"]
    pub fn ucl_object_todouble(obj: *const ucl_object_t) -> f64;
}
extern "C" {
    #[doc = " Converts an object to integer value"]
    #[doc = " @param obj CL object"]
    #[doc = " @param target target integer variable"]
    #[doc = " @return true if conversion was successful"]
    pub fn ucl_object_toint_safe(obj: *const ucl_object_t, target: *mut i64) -> bool;
}
extern "C" {
    #[doc = " Unsafe version of \\ref ucl_obj_toint_safe"]
    #[doc = " @param obj CL object"]
    #[doc = " @return int value"]
    pub fn ucl_object_toint(obj: *const ucl_object_t) -> i64;
}
extern "C" {
    #[doc = " Converts an object to boolean value"]
    #[doc = " @param obj CL object"]
    #[doc = " @param target target boolean variable"]
    #[doc = " @return true if conversion was successful"]
    pub fn ucl_object_toboolean_safe(obj: *const ucl_object_t, target: *mut bool) -> bool;
}
extern "C" {
    #[doc = " Unsafe version of \\ref ucl_obj_toboolean_safe"]
    #[doc = " @param obj CL object"]
    #[doc = " @return boolean value"]
    pub fn ucl_object_toboolean(obj: *const ucl_object_t) -> bool;
}
extern "C" {
    #[doc = " Converts an object to string value"]
    #[doc = " @param obj CL object"]
    #[doc = " @param target target string variable, no need to free value"]
    #[doc = " @return true if conversion was successful"]
    pub fn ucl_object_tostring_safe(
        obj: *const ucl_object_t,
        target: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Unsafe version of \\ref ucl_obj_tostring_safe"]
    #[doc = " @param obj CL object"]
    #[doc = " @return string value"]
    pub fn ucl_object_tostring(obj: *const ucl_object_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert any object to a string in JSON notation if needed"]
    #[doc = " @param obj CL object"]
    #[doc = " @return string value"]
    pub fn ucl_object_tostring_forced(obj: *const ucl_object_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return string as char * and len, string may be not zero terminated, more efficient that \\ref ucl_obj_tostring as it"]
    #[doc = " allows zero-copy (if #UCL_PARSER_ZEROCOPY has been used during parsing)"]
    #[doc = " @param obj CL object"]
    #[doc = " @param target target string variable, no need to free value"]
    #[doc = " @param tlen target length"]
    #[doc = " @return true if conversion was successful"]
    pub fn ucl_object_tolstring_safe(
        obj: *const ucl_object_t,
        target: *mut *const ::std::os::raw::c_char,
        tlen: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Unsafe version of \\ref ucl_obj_tolstring_safe"]
    #[doc = " @param obj CL object"]
    #[doc = " @return string value"]
    pub fn ucl_object_tolstring(
        obj: *const ucl_object_t,
        tlen: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return object identified by a key in the specified object"]
    #[doc = " @param obj object to get a key from (must be of type UCL_OBJECT)"]
    #[doc = " @param key key to search"]
    #[doc = " @return object matching the specified key or NULL if key was not found"]
    pub fn ucl_object_lookup(
        obj: *const ucl_object_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Return object identified by a key in the specified object, if the first key is"]
    #[doc = " not found then look for the next one. This process is repeated unless"]
    #[doc = " the next argument in the list is not NULL. So, `ucl_object_find_any_key(obj, key, NULL)`"]
    #[doc = " is equal to `ucl_object_find_key(obj, key)`"]
    #[doc = " @param obj object to get a key from (must be of type UCL_OBJECT)"]
    #[doc = " @param key key to search"]
    #[doc = " @param ... list of alternative keys to search (NULL terminated)"]
    #[doc = " @return object matching the specified key or NULL if key was not found"]
    pub fn ucl_object_lookup_any(
        obj: *const ucl_object_t,
        key: *const ::std::os::raw::c_char,
        ...
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Return object identified by a fixed size key in the specified object"]
    #[doc = " @param obj object to get a key from (must be of type UCL_OBJECT)"]
    #[doc = " @param key key to search"]
    #[doc = " @param klen length of a key"]
    #[doc = " @return object matching the specified key or NULL if key was not found"]
    pub fn ucl_object_lookup_len(
        obj: *const ucl_object_t,
        key: *const ::std::os::raw::c_char,
        klen: usize,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Return object identified by dot notation string"]
    #[doc = " @param obj object to search in"]
    #[doc = " @param path dot.notation.path to the path to lookup. May use numeric .index on arrays"]
    #[doc = " @return object matched the specified path or NULL if path is not found"]
    pub fn ucl_object_lookup_path(
        obj: *const ucl_object_t,
        path: *const ::std::os::raw::c_char,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Return object identified by object notation string using arbitrary delimiter"]
    #[doc = " @param obj object to search in"]
    #[doc = " @param path dot.notation.path to the path to lookup. May use numeric .index on arrays"]
    #[doc = " @param sep the sepatorator to use in place of . (incase keys have . in them)"]
    #[doc = " @return object matched the specified path or NULL if path is not found"]
    pub fn ucl_object_lookup_path_char(
        obj: *const ucl_object_t,
        path: *const ::std::os::raw::c_char,
        sep: ::std::os::raw::c_char,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Returns a key of an object as a NULL terminated string"]
    #[doc = " @param obj CL object"]
    #[doc = " @return key or NULL if there is no key"]
    pub fn ucl_object_key(obj: *const ucl_object_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a key of an object as a fixed size string (may be more efficient)"]
    #[doc = " @param obj CL object"]
    #[doc = " @param len target key length"]
    #[doc = " @return key pointer"]
    pub fn ucl_object_keyl(
        obj: *const ucl_object_t,
        len: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Increase reference count for an object"]
    #[doc = " @param obj object to ref"]
    #[doc = " @return the referenced object"]
    pub fn ucl_object_ref(obj: *const ucl_object_t) -> *mut ucl_object_t;
}
extern "C" {
    pub fn ucl_object_free(obj: *mut ucl_object_t);
}
extern "C" {
    #[doc = " Decrease reference count for an object"]
    #[doc = " @param obj object to unref"]
    pub fn ucl_object_unref(obj: *mut ucl_object_t);
}
extern "C" {
    #[doc = " Compare objects `o1` and `o2`"]
    #[doc = " @param o1 the first object"]
    #[doc = " @param o2 the second object"]
    #[doc = " @return values >0, 0 and <0 if `o1` is more than, equal and less than `o2`."]
    #[doc = " The order of comparison:"]
    #[doc = " 1) Type of objects"]
    #[doc = " 2) Size of objects"]
    #[doc = " 3) Content of objects"]
    pub fn ucl_object_compare(
        o1: *const ucl_object_t,
        o2: *const ucl_object_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare objects `o1` and `o2` useful for sorting"]
    #[doc = " @param o1 the first object"]
    #[doc = " @param o2 the second object"]
    #[doc = " @return values >0, 0 and <0 if `o1` is more than, equal and less than `o2`."]
    #[doc = " The order of comparison:"]
    #[doc = " 1) Type of objects"]
    #[doc = " 2) Size of objects"]
    #[doc = " 3) Content of objects"]
    pub fn ucl_object_compare_qsort(
        o1: *mut *const ucl_object_t,
        o2: *mut *const ucl_object_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sort UCL array using `cmp` compare function"]
    #[doc = " @param ar"]
    #[doc = " @param cmp"]
    pub fn ucl_object_array_sort(
        ar: *mut ucl_object_t,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                o1: *mut *const ucl_object_t,
                o2: *mut *const ucl_object_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Get the priority for specific UCL object"]
    #[doc = " @param obj any ucl object"]
    #[doc = " @return priority of an object"]
    pub fn ucl_object_get_priority(obj: *const ucl_object_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Set explicit priority of an object."]
    #[doc = " @param obj any ucl object"]
    #[doc = " @param priority new priroity value (only 4 least significant bits are considred)"]
    pub fn ucl_object_set_priority(obj: *mut ucl_object_t, priority: ::std::os::raw::c_uint);
}
#[doc = " Opaque iterator object"]
pub type ucl_object_iter_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " Get next key from an object"]
    #[doc = " @param obj object to iterate"]
    #[doc = " @param iter opaque iterator, must be set to NULL on the first call:"]
    #[doc = " ucl_object_iter_t it = NULL;"]
    #[doc = " while ((cur = ucl_iterate_object (obj, &it)) != NULL) ..."]
    #[doc = " @return the next object or NULL"]
    pub fn ucl_object_iterate(
        obj: *const ucl_object_t,
        iter: *mut ucl_object_iter_t,
        expand_values: bool,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Create new safe iterator for the specified object"]
    #[doc = " @param obj object to iterate"]
    #[doc = " @return new iterator object that should be used with safe iterators API only"]
    pub fn ucl_object_iterate_new(obj: *const ucl_object_t) -> ucl_object_iter_t;
}
extern "C" {
    #[doc = " Reset initialized iterator to a new object"]
    #[doc = " @param obj new object to iterate"]
    #[doc = " @return modified iterator object"]
    pub fn ucl_object_iterate_reset(
        it: ucl_object_iter_t,
        obj: *const ucl_object_t,
    ) -> ucl_object_iter_t;
}
extern "C" {
    #[doc = " Get the next object from the `obj`. This fucntion iterates over arrays, objects"]
    #[doc = " and implicit arrays"]
    #[doc = " @param iter safe iterator"]
    #[doc = " @param expand_values expand explicit arrays and objects"]
    #[doc = " @return the next object in sequence"]
    pub fn ucl_object_iterate_safe(
        iter: ucl_object_iter_t,
        expand_values: bool,
    ) -> *const ucl_object_t;
}
#[repr(u32)]
#[doc = " Iteration type enumerator"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ucl_iterate_type {
    #[doc = "< Iterate just explicit arrays and objects"]
    UCL_ITERATE_EXPLICIT = 1,
    #[doc = "< Iterate just implicit arrays"]
    UCL_ITERATE_IMPLICIT = 2,
    #[doc = "< Iterate both explicit and implicit arrays"]
    UCL_ITERATE_BOTH = 3,
}
extern "C" {
    #[doc = " Get the next object from the `obj`. This fucntion iterates over arrays, objects"]
    #[doc = " and implicit arrays if needed"]
    #[doc = " @param iter safe iterator"]
    #[doc = " @param"]
    #[doc = " @return the next object in sequence"]
    pub fn ucl_object_iterate_full(
        iter: ucl_object_iter_t,
        type_: ucl_iterate_type,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Free memory associated with the safe iterator"]
    #[doc = " @param it safe iterator object"]
    pub fn ucl_object_iterate_free(it: ucl_object_iter_t);
}
#[doc = " Macro handler for a parser"]
#[doc = " @param data the content of macro"]
#[doc = " @param len the length of content"]
#[doc = " @param arguments arguments object"]
#[doc = " @param ud opaque user data"]
#[doc = " @param err error pointer"]
#[doc = " @return true if macro has been parsed"]
pub type ucl_macro_handler = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_uchar,
        len: usize,
        arguments: *const ucl_object_t,
        ud: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Context dependent macro handler for a parser"]
#[doc = " @param data the content of macro"]
#[doc = " @param len the length of content"]
#[doc = " @param arguments arguments object"]
#[doc = " @param context previously parsed context"]
#[doc = " @param ud opaque user data"]
#[doc = " @param err error pointer"]
#[doc = " @return true if macro has been parsed"]
pub type ucl_context_macro_handler = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_uchar,
        len: usize,
        arguments: *const ucl_object_t,
        context: *const ucl_object_t,
        ud: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucl_parser {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates new parser object"]
    #[doc = " @param pool pool to allocate memory from"]
    #[doc = " @return new parser object"]
    pub fn ucl_parser_new(flags: ::std::os::raw::c_int) -> *mut ucl_parser;
}
extern "C" {
    #[doc = " Sets the default priority for the parser applied to chunks that does not"]
    #[doc = " specify priority explicitly"]
    #[doc = " @param parser parser object"]
    #[doc = " @param prio default priority (0 .. 16)"]
    #[doc = " @return true if parser's default priority was set"]
    pub fn ucl_parser_set_default_priority(
        parser: *mut ucl_parser,
        prio: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Register new handler for a macro"]
    #[doc = " @param parser parser object"]
    #[doc = " @param macro macro name (without leading dot)"]
    #[doc = " @param handler handler (it is called immediately after macro is parsed)"]
    #[doc = " @param ud opaque user data for a handler"]
    pub fn ucl_parser_register_macro(
        parser: *mut ucl_parser,
        macro_: *const ::std::os::raw::c_char,
        handler: ucl_macro_handler,
        ud: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Register new context dependent handler for a macro"]
    #[doc = " @param parser parser object"]
    #[doc = " @param macro macro name (without leading dot)"]
    #[doc = " @param handler handler (it is called immediately after macro is parsed)"]
    #[doc = " @param ud opaque user data for a handler"]
    pub fn ucl_parser_register_context_macro(
        parser: *mut ucl_parser,
        macro_: *const ::std::os::raw::c_char,
        handler: ucl_context_macro_handler,
        ud: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Handler to detect unregistered variables"]
#[doc = " @param data variable data"]
#[doc = " @param len length of variable"]
#[doc = " @param replace (out) replace value for variable"]
#[doc = " @param replace_len (out) replace length for variable"]
#[doc = " @param need_free (out) UCL will free `dest` after usage"]
#[doc = " @param ud opaque userdata"]
#[doc = " @return true if variable"]
pub type ucl_variable_handler = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_uchar,
        len: usize,
        replace: *mut *mut ::std::os::raw::c_uchar,
        replace_len: *mut usize,
        need_free: *mut bool,
        ud: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Register new parser variable"]
    #[doc = " @param parser parser object"]
    #[doc = " @param var variable name"]
    #[doc = " @param value variable value"]
    pub fn ucl_parser_register_variable(
        parser: *mut ucl_parser,
        var: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set handler for unknown variables"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param handler desired handler"]
    #[doc = " @param ud opaque data for the handler"]
    pub fn ucl_parser_set_variables_handler(
        parser: *mut ucl_parser,
        handler: ucl_variable_handler,
        ud: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Load new chunk to a parser"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param data the pointer to the beginning of a chunk"]
    #[doc = " @param len the length of a chunk"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_chunk(
        parser: *mut ucl_parser,
        data: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Load new chunk to a parser with the specified priority"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param data the pointer to the beginning of a chunk"]
    #[doc = " @param len the length of a chunk"]
    #[doc = " @param priority the desired priority of a chunk (only 4 least significant bits"]
    #[doc = " are considered for this parameter)"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_chunk_priority(
        parser: *mut ucl_parser,
        data: *const ::std::os::raw::c_uchar,
        len: usize,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Full version of ucl_add_chunk with priority and duplicate strategy"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param data the pointer to the beginning of a chunk"]
    #[doc = " @param len the length of a chunk"]
    #[doc = " @param priority the desired priority of a chunk (only 4 least significant bits"]
    #[doc = " are considered for this parameter)"]
    #[doc = " @param strat duplicates merging strategy"]
    #[doc = " @param parse_type input format"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_chunk_full(
        parser: *mut ucl_parser,
        data: *const ::std::os::raw::c_uchar,
        len: usize,
        priority: ::std::os::raw::c_uint,
        strat: ucl_duplicate_strategy,
        parse_type: ucl_parse_type,
    ) -> bool;
}
extern "C" {
    #[doc = " Load ucl object from a string"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param data the pointer to the string"]
    #[doc = " @param len the length of the string, if `len` is 0 then `data` must be zero-terminated string"]
    #[doc = " @return true if string has been added and false in case of error"]
    pub fn ucl_parser_add_string(
        parser: *mut ucl_parser,
        data: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Load ucl object from a string"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param data the pointer to the string"]
    #[doc = " @param len the length of the string, if `len` is 0 then `data` must be zero-terminated string"]
    #[doc = " @param priority the desired priority of a chunk (only 4 least significant bits"]
    #[doc = " are considered for this parameter)"]
    #[doc = " @return true if string has been added and false in case of error"]
    pub fn ucl_parser_add_string_priority(
        parser: *mut ucl_parser,
        data: *const ::std::os::raw::c_char,
        len: usize,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Load and add data from a file"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param filename the name of file"]
    #[doc = " @param err if *err is NULL it is set to parser error"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_file(
        parser: *mut ucl_parser,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Load and add data from a file"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param filename the name of file"]
    #[doc = " @param err if *err is NULL it is set to parser error"]
    #[doc = " @param priority the desired priority of a chunk (only 4 least significant bits"]
    #[doc = " are considered for this parameter)"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_file_priority(
        parser: *mut ucl_parser,
        filename: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Load and add data from a file"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param filename the name of file"]
    #[doc = " @param priority the desired priority of a chunk (only 4 least significant bits"]
    #[doc = " are considered for this parameter)"]
    #[doc = " @param strat Merge strategy to use while parsing this file"]
    #[doc = " @param parse_type Parser type to use while parsing this file"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_file_full(
        parser: *mut ucl_parser,
        filename: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_uint,
        strat: ucl_duplicate_strategy,
        parse_type: ucl_parse_type,
    ) -> bool;
}
extern "C" {
    #[doc = " Load and add data from a file descriptor"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param filename the name of file"]
    #[doc = " @param err if *err is NULL it is set to parser error"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_fd(parser: *mut ucl_parser, fd: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Load and add data from a file descriptor"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param filename the name of file"]
    #[doc = " @param err if *err is NULL it is set to parser error"]
    #[doc = " @param priority the desired priority of a chunk (only 4 least significant bits"]
    #[doc = " are considered for this parameter)"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_fd_priority(
        parser: *mut ucl_parser,
        fd: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Load and add data from a file descriptor"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param filename the name of file"]
    #[doc = " @param err if *err is NULL it is set to parser error"]
    #[doc = " @param priority the desired priority of a chunk (only 4 least significant bits"]
    #[doc = " are considered for this parameter)"]
    #[doc = " @param strat Merge strategy to use while parsing this file"]
    #[doc = " @param parse_type Parser type to use while parsing this file"]
    #[doc = " @return true if chunk has been added and false in case of error"]
    pub fn ucl_parser_add_fd_full(
        parser: *mut ucl_parser,
        fd: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_uint,
        strat: ucl_duplicate_strategy,
        parse_type: ucl_parse_type,
    ) -> bool;
}
extern "C" {
    #[doc = " Provide a UCL_ARRAY of paths to search for include files. The object is"]
    #[doc = " copied so caller must unref the object."]
    #[doc = " @param parser parser structure"]
    #[doc = " @param paths UCL_ARRAY of paths to search"]
    #[doc = " @return true if the path search array was replaced in the parser"]
    pub fn ucl_set_include_path(parser: *mut ucl_parser, paths: *mut ucl_object_t) -> bool;
}
extern "C" {
    #[doc = " Get a top object for a parser (refcount is increased)"]
    #[doc = " @param parser parser structure"]
    #[doc = " @param err if *err is NULL it is set to parser error"]
    #[doc = " @return top parser object or NULL"]
    pub fn ucl_parser_get_object(parser: *mut ucl_parser) -> *mut ucl_object_t;
}
extern "C" {
    #[doc = " Get the error string if parsing has been failed"]
    #[doc = " @param parser parser object"]
    #[doc = " @return error description"]
    pub fn ucl_parser_get_error(parser: *mut ucl_parser) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the code of the last error"]
    #[doc = " @param parser parser object"]
    #[doc = " @return error code"]
    pub fn ucl_parser_get_error_code(parser: *mut ucl_parser) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current column number within parser"]
    #[doc = " @param parser parser object"]
    #[doc = " @return current column number"]
    pub fn ucl_parser_get_column(parser: *mut ucl_parser) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the current line number within parser"]
    #[doc = " @param parser parser object"]
    #[doc = " @return current line number"]
    pub fn ucl_parser_get_linenum(parser: *mut ucl_parser) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Clear the error in the parser"]
    #[doc = " @param parser parser object"]
    pub fn ucl_parser_clear_error(parser: *mut ucl_parser);
}
extern "C" {
    #[doc = " Free ucl parser object"]
    #[doc = " @param parser parser object"]
    pub fn ucl_parser_free(parser: *mut ucl_parser);
}
extern "C" {
    #[doc = " Get constant opaque pointer to comments structure for this parser. Increase"]
    #[doc = " refcount to prevent this object to be destroyed on parser's destruction"]
    #[doc = " @param parser parser structure"]
    #[doc = " @return ucl comments pointer or NULL"]
    pub fn ucl_parser_get_comments(parser: *mut ucl_parser) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Utility function to find a comment object for the specified object in the input"]
    #[doc = " @param comments comments object"]
    #[doc = " @param srch search object"]
    #[doc = " @return string comment enclosed in ucl_object_t"]
    pub fn ucl_comments_find(
        comments: *const ucl_object_t,
        srch: *const ucl_object_t,
    ) -> *const ucl_object_t;
}
extern "C" {
    #[doc = " Move comment from `from` object to `to` object"]
    #[doc = " @param comments comments object"]
    #[doc = " @param what source object"]
    #[doc = " @param whith destination object"]
    #[doc = " @return `true` if `from` has comment and it has been moved to `to`"]
    pub fn ucl_comments_move(
        comments: *mut ucl_object_t,
        from: *const ucl_object_t,
        to: *const ucl_object_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Adds a new comment for an object"]
    #[doc = " @param comments comments object"]
    #[doc = " @param obj object to add comment to"]
    #[doc = " @param comment string representation of a comment"]
    pub fn ucl_comments_add(
        comments: *mut ucl_object_t,
        obj: *const ucl_object_t,
        comment: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add new public key to parser for signatures check"]
    #[doc = " @param parser parser object"]
    #[doc = " @param key PEM representation of a key"]
    #[doc = " @param len length of the key"]
    #[doc = " @param err if *err is NULL it is set to parser error"]
    #[doc = " @return true if a key has been successfully added"]
    pub fn ucl_parser_pubkey_add(
        parser: *mut ucl_parser,
        key: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Set FILENAME and CURDIR variables in parser"]
    #[doc = " @param parser parser object"]
    #[doc = " @param filename filename to set or NULL to set FILENAME to \"undef\" and CURDIR to getcwd()"]
    #[doc = " @param need_expand perform realpath() if this variable is true and filename is not NULL"]
    #[doc = " @return true if variables has been set"]
    pub fn ucl_parser_set_filevars(
        parser: *mut ucl_parser,
        filename: *const ::std::os::raw::c_char,
        need_expand: bool,
    ) -> bool;
}
#[doc = " Structure using for emitter callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucl_emitter_functions {
    #[doc = " Append a single character"]
    pub ucl_emitter_append_character: ::std::option::Option<
        unsafe extern "C" fn(
            c: ::std::os::raw::c_uchar,
            nchars: usize,
            ud: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Append a string of a specified length"]
    pub ucl_emitter_append_len: ::std::option::Option<
        unsafe extern "C" fn(
            str: *const ::std::os::raw::c_uchar,
            len: usize,
            ud: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Append a 64 bit integer"]
    pub ucl_emitter_append_int: ::std::option::Option<
        unsafe extern "C" fn(elt: i64, ud: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " Append floating point element"]
    pub ucl_emitter_append_double: ::std::option::Option<
        unsafe extern "C" fn(elt: f64, ud: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " Free userdata"]
    pub ucl_emitter_free_func:
        ::std::option::Option<unsafe extern "C" fn(ud: *mut ::std::os::raw::c_void)>,
    #[doc = " Opaque userdata pointer"]
    pub ud: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ucl_emitter_functions() {
    assert_eq!(
        ::std::mem::size_of::<ucl_emitter_functions>(),
        48usize,
        concat!("Size of: ", stringify!(ucl_emitter_functions))
    );
    assert_eq!(
        ::std::mem::align_of::<ucl_emitter_functions>(),
        8usize,
        concat!("Alignment of ", stringify!(ucl_emitter_functions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_functions>())).ucl_emitter_append_character
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_functions),
            "::",
            stringify!(ucl_emitter_append_character)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_functions>())).ucl_emitter_append_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_functions),
            "::",
            stringify!(ucl_emitter_append_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_functions>())).ucl_emitter_append_int as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_functions),
            "::",
            stringify!(ucl_emitter_append_int)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_functions>())).ucl_emitter_append_double as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_functions),
            "::",
            stringify!(ucl_emitter_append_double)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_functions>())).ucl_emitter_free_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_functions),
            "::",
            stringify!(ucl_emitter_free_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_functions>())).ud as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_functions),
            "::",
            stringify!(ud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucl_emitter_operations {
    #[doc = " Write a primitive element"]
    pub ucl_emitter_write_elt: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ucl_emitter_context,
            obj: *const ucl_object_t,
            first: bool,
            print_key: bool,
        ),
    >,
    #[doc = " Start ucl object"]
    pub ucl_emitter_start_object: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ucl_emitter_context,
            obj: *const ucl_object_t,
            print_key: bool,
        ),
    >,
    #[doc = " End ucl object"]
    pub ucl_emitter_end_object: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ucl_emitter_context, obj: *const ucl_object_t),
    >,
    #[doc = " Start ucl array"]
    pub ucl_emitter_start_array: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ucl_emitter_context,
            obj: *const ucl_object_t,
            print_key: bool,
        ),
    >,
    pub ucl_emitter_end_array: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ucl_emitter_context, obj: *const ucl_object_t),
    >,
}
#[test]
fn bindgen_test_layout_ucl_emitter_operations() {
    assert_eq!(
        ::std::mem::size_of::<ucl_emitter_operations>(),
        40usize,
        concat!("Size of: ", stringify!(ucl_emitter_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<ucl_emitter_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(ucl_emitter_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_operations>())).ucl_emitter_write_elt as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_operations),
            "::",
            stringify!(ucl_emitter_write_elt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_operations>())).ucl_emitter_start_object as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_operations),
            "::",
            stringify!(ucl_emitter_start_object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_operations>())).ucl_emitter_end_object as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_operations),
            "::",
            stringify!(ucl_emitter_end_object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_operations>())).ucl_emitter_start_array as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_operations),
            "::",
            stringify!(ucl_emitter_start_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ucl_emitter_operations>())).ucl_emitter_end_array as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_operations),
            "::",
            stringify!(ucl_emitter_end_array)
        )
    );
}
#[doc = " @defgroup emitter Emitting functions"]
#[doc = " These functions are used to serialise UCL objects to some string representation."]
#[doc = ""]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucl_emitter_context {
    #[doc = " Name of emitter (e.g. json, compact_json)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Unique id (e.g. UCL_EMIT_JSON for standard emitters"]
    pub id: ::std::os::raw::c_int,
    #[doc = " A set of output functions"]
    pub func: *const ucl_emitter_functions,
    #[doc = " A set of output operations"]
    pub ops: *const ucl_emitter_operations,
    #[doc = " Current amount of indent tabs"]
    pub indent: ::std::os::raw::c_uint,
    #[doc = " Top level object"]
    pub top: *const ucl_object_t,
    #[doc = " Optional comments"]
    pub comments: *const ucl_object_t,
}
#[test]
fn bindgen_test_layout_ucl_emitter_context() {
    assert_eq!(
        ::std::mem::size_of::<ucl_emitter_context>(),
        56usize,
        concat!("Size of: ", stringify!(ucl_emitter_context))
    );
    assert_eq!(
        ::std::mem::align_of::<ucl_emitter_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ucl_emitter_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_context>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_context),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_context>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_context),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_context>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_context),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_context>())).ops as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_context),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_context>())).indent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_context),
            "::",
            stringify!(indent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_context>())).top as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_context),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_emitter_context>())).comments as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_emitter_context),
            "::",
            stringify!(comments)
        )
    );
}
extern "C" {
    #[doc = " Emit object to a string"]
    #[doc = " @param obj object"]
    #[doc = " @param emit_type if type is #UCL_EMIT_JSON then emit json, if type is"]
    #[doc = " #UCL_EMIT_CONFIG then emit config like object"]
    #[doc = " @return dump of an object (must be freed after using) or NULL in case of error"]
    pub fn ucl_object_emit(
        obj: *const ucl_object_t,
        emit_type: ucl_emitter,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Emit object to a string that can contain `\\0` inside"]
    #[doc = " @param obj object"]
    #[doc = " @param emit_type if type is #UCL_EMIT_JSON then emit json, if type is"]
    #[doc = " #UCL_EMIT_CONFIG then emit config like object"]
    #[doc = " @param len the resulting length"]
    #[doc = " @return dump of an object (must be freed after using) or NULL in case of error"]
    pub fn ucl_object_emit_len(
        obj: *const ucl_object_t,
        emit_type: ucl_emitter,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Emit object to a string"]
    #[doc = " @param obj object"]
    #[doc = " @param emit_type if type is #UCL_EMIT_JSON then emit json, if type is"]
    #[doc = " #UCL_EMIT_CONFIG then emit config like object"]
    #[doc = " @param emitter a set of emitter functions"]
    #[doc = " @param comments optional comments for the parser"]
    #[doc = " @return dump of an object (must be freed after using) or NULL in case of error"]
    pub fn ucl_object_emit_full(
        obj: *const ucl_object_t,
        emit_type: ucl_emitter,
        emitter: *mut ucl_emitter_functions,
        comments: *const ucl_object_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Start streamlined UCL object emitter"]
    #[doc = " @param obj top UCL object"]
    #[doc = " @param emit_type emit type"]
    #[doc = " @param emitter a set of emitter functions"]
    #[doc = " @return new streamlined context that should be freed by"]
    #[doc = " `ucl_object_emit_streamline_finish`"]
    pub fn ucl_object_emit_streamline_new(
        obj: *const ucl_object_t,
        emit_type: ucl_emitter,
        emitter: *mut ucl_emitter_functions,
    ) -> *mut ucl_emitter_context;
}
extern "C" {
    #[doc = " Start object or array container for the streamlined output"]
    #[doc = " @param ctx streamlined context"]
    #[doc = " @param obj container object"]
    pub fn ucl_object_emit_streamline_start_container(
        ctx: *mut ucl_emitter_context,
        obj: *const ucl_object_t,
    );
}
extern "C" {
    #[doc = " Add a complete UCL object to streamlined output"]
    #[doc = " @param ctx streamlined context"]
    #[doc = " @param obj object to output"]
    pub fn ucl_object_emit_streamline_add_object(
        ctx: *mut ucl_emitter_context,
        obj: *const ucl_object_t,
    );
}
extern "C" {
    #[doc = " End previously added container"]
    #[doc = " @param ctx streamlined context"]
    pub fn ucl_object_emit_streamline_end_container(ctx: *mut ucl_emitter_context);
}
extern "C" {
    #[doc = " Terminate streamlined container finishing all containers in it"]
    #[doc = " @param ctx streamlined context"]
    pub fn ucl_object_emit_streamline_finish(ctx: *mut ucl_emitter_context);
}
extern "C" {
    #[doc = " Returns functions to emit object to memory"]
    #[doc = " @param pmem target pointer (should be freed by caller)"]
    #[doc = " @return emitter functions structure"]
    pub fn ucl_object_emit_memory_funcs(
        pmem: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ucl_emitter_functions;
}
extern "C" {
    #[doc = " Returns functions to emit object to a file descriptor"]
    #[doc = " @param fd file descriptor"]
    #[doc = " @return emitter functions structure"]
    pub fn ucl_object_emit_fd_funcs(fd: ::std::os::raw::c_int) -> *mut ucl_emitter_functions;
}
extern "C" {
    #[doc = " Free emitter functions"]
    #[doc = " @param f pointer to functions"]
    pub fn ucl_object_emit_funcs_free(f: *mut ucl_emitter_functions);
}
#[repr(u32)]
#[doc = " Used to define UCL schema error"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ucl_schema_error_code {
    #[doc = "< no error"]
    UCL_SCHEMA_OK = 0,
    #[doc = "< type of object is incorrect"]
    UCL_SCHEMA_TYPE_MISMATCH = 1,
    #[doc = "< schema is invalid"]
    UCL_SCHEMA_INVALID_SCHEMA = 2,
    #[doc = "< one or more missing properties"]
    UCL_SCHEMA_MISSING_PROPERTY = 3,
    #[doc = "< constraint found"]
    UCL_SCHEMA_CONSTRAINT = 4,
    #[doc = "< missing dependency"]
    UCL_SCHEMA_MISSING_DEPENDENCY = 5,
    #[doc = "< cannot fetch external ref"]
    UCL_SCHEMA_EXTERNAL_REF_MISSING = 6,
    #[doc = "< invalid external ref"]
    UCL_SCHEMA_EXTERNAL_REF_INVALID = 7,
    #[doc = "< something bad happened"]
    UCL_SCHEMA_INTERNAL_ERROR = 8,
    #[doc = "< generic error"]
    UCL_SCHEMA_UNKNOWN = 9,
}
#[doc = " Generic ucl schema error"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucl_schema_error {
    #[doc = "< error code"]
    pub code: ucl_schema_error_code,
    #[doc = "< error message"]
    pub msg: [::std::os::raw::c_char; 128usize],
    #[doc = "< object where error occured"]
    pub obj: *const ucl_object_t,
}
#[test]
fn bindgen_test_layout_ucl_schema_error() {
    assert_eq!(
        ::std::mem::size_of::<ucl_schema_error>(),
        144usize,
        concat!("Size of: ", stringify!(ucl_schema_error))
    );
    assert_eq!(
        ::std::mem::align_of::<ucl_schema_error>(),
        8usize,
        concat!("Alignment of ", stringify!(ucl_schema_error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_schema_error>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_schema_error),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_schema_error>())).msg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_schema_error),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucl_schema_error>())).obj as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ucl_schema_error),
            "::",
            stringify!(obj)
        )
    );
}
extern "C" {
    #[doc = " Validate object `obj` using schema object `schema`."]
    #[doc = " @param schema schema object"]
    #[doc = " @param obj object to validate"]
    #[doc = " @param err error pointer, if this parameter is not NULL and error has been"]
    #[doc = " occured, then `err` is filled with the exact error definition."]
    #[doc = " @return true if `obj` is valid using `schema`"]
    pub fn ucl_object_validate(
        schema: *const ucl_object_t,
        obj: *const ucl_object_t,
        err: *mut ucl_schema_error,
    ) -> bool;
}
extern "C" {
    #[doc = " Validate object `obj` using schema object `schema` and root schema at `root`."]
    #[doc = " @param schema schema object"]
    #[doc = " @param obj object to validate"]
    #[doc = " @param root root schema object"]
    #[doc = " @param err error pointer, if this parameter is not NULL and error has been"]
    #[doc = " occured, then `err` is filled with the exact error definition."]
    #[doc = " @return true if `obj` is valid using `schema`"]
    pub fn ucl_object_validate_root(
        schema: *const ucl_object_t,
        obj: *const ucl_object_t,
        root: *const ucl_object_t,
        err: *mut ucl_schema_error,
    ) -> bool;
}
extern "C" {
    #[doc = " Validate object `obj` using schema object `schema` and root schema at `root`"]
    #[doc = " using some external references provided."]
    #[doc = " @param schema schema object"]
    #[doc = " @param obj object to validate"]
    #[doc = " @param root root schema object"]
    #[doc = " @param ext_refs external references (might be modified during validation)"]
    #[doc = " @param err error pointer, if this parameter is not NULL and error has been"]
    #[doc = " occured, then `err` is filled with the exact error definition."]
    #[doc = " @return true if `obj` is valid using `schema`"]
    pub fn ucl_object_validate_root_ext(
        schema: *const ucl_object_t,
        obj: *const ucl_object_t,
        root: *const ucl_object_t,
        ext_refs: *mut ucl_object_t,
        err: *mut ucl_schema_error,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    pub _address: u8,
}
